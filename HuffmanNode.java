import java.io.IOException;
import java.util.*;
import java.util.PriorityQueue;
import java.io.FileWriter;
import java.io.File;


public class HuffmanNode {
    //data is the frequency of the letter//
    public int data;
    public char c;
    public HuffmanNode left;
    public HuffmanNode right;

    //A method to compare the frequency of the letters//
    public static class MyComparator implements Comparator<HuffmanNode> {
        @Override
        public int compare(HuffmanNode x, HuffmanNode y) {
            return x.data - y.data;
        }
    }

    //A method to print the huffman nodes//
    public static void printCode(HuffmanNode root, String s){
        // base case; if the left and right are null
        // then its a leaf node and we print
        // the code s generated by traversing the tree.
        if (root.left == null && root.right == null){
        System.out.println(root.c + " | " + root.data +" | " + s);
        return;
        }
        // if we go to left then add "0" to the code.
        // if we go to the right add"1" to the code.
        // recursive calls for left and
        // right sub-tree of the generated tree.
        printCode(root.left,s + "0");
        printCode(root.right,s + "1");
    }

 //This method is used to writeHuffmanTree into the output file//
    public static void writeHuffmanTree(HuffmanNode root, String s, String fileName, FileWriter fw) throws IOException {
        // base case; if the left and right are null
        // then its a leaf node and we print
        // the code s generated by traversing the tree.
        if (root.left == null && root.right == null){
            fw.write(root.c + " | " + root.data +" | " + s + "\r\n");
            return;
        }
        writeHuffmanTree(root.left, s + "0",fileName,fw);
        writeHuffmanTree(root.right, s + "1",fileName,fw);
    }

    //This method is used to put HuffmanNodes into Two LinkedList
    // CharList and CodeList (for translate text into 0 and 1)//
    //A method to traverse the Huffman tree to output the character encoding,
    public static void recordHuffmanNodes(LinkedList<Character> Charlist,LinkedList<String> CodeList,HuffmanNode root, String s){
        if (root.left == null && root.right == null){
            Charlist.add(root.c);
            CodeList.add(s);
            return;
            }
        recordHuffmanNodes(Charlist,CodeList,root.left,s + "0");
        recordHuffmanNodes(Charlist,CodeList,root.right,s + "1");
        }




//generate HuffmanTree and write into output file//
    //A method to run the Huffman encoding algorithm to produce the Huffman tree,//
    public static void HuffmanTreeGenerate(HashMap<Character, Integer> FrequencyMapInitial,
                                           LinkedList<Character> Charlist, LinkedList<String> CodeList
            , String inputFilepath, String filename) throws IOException {
        //First we sort the HashMap by char's frequency//
        HashMap<Character, Integer> FrequencyMap = HuffmanCoderReadWrite.sortByValue(FrequencyMapInitial);
        int n = FrequencyMap.size();
        Set key = FrequencyMap.keySet();
        Character[] charkeys = (Character[])key.toArray(new Character[key.size()]);
        Integer[] values = FrequencyMap.values().toArray(new Integer[key.size()]);

        //ArrayList have higher speed in getMethod, but Linkedlist have higher speed in addMethod, I would prefer LinkedList
        // because  it have higher speed in add, we need go through all the text to generate the frequency table. (Even though we
        // still need to get all the data to generate the Huffman coding. )

        PriorityQueue<HuffmanNode> list
                = new PriorityQueue<HuffmanNode>(n, new MyComparator());
        for (int i = 0; i <n; i++){
            //add all the HuffmanNodes into a linkedlist//
            HuffmanNode hn = new HuffmanNode();
            hn.c = charkeys[i];
            hn.data = values[i];
            hn.left = null;
            hn.right = null;
            list.add(hn);
        }
        HuffmanNodeCombine(list, Charlist,CodeList,inputFilepath,filename);
    }

    //A method to merge two HuffmanNodes and return the combined HuffmanNode,//
    private static void HuffmanNodeCombine(PriorityQueue<HuffmanNode> list,
                                           LinkedList<Character> Charlist,LinkedList<String> CodeList,String inputFilepath,String filename) throws IOException {
        HuffmanNode root = null;
        while(list.size() >1){
            //first min extract
            HuffmanNode x = list.peek();
            list.poll();
            //second min extract
            HuffmanNode y = list.peek();
            list.poll();
            //this new node f's frequency would equal to the last two nodes.
            HuffmanNode f = new HuffmanNode();
            f.data = x.data + y.data;
            f.c = '-';
            f.left = y;
            f.right = x;
            root = f;
            //then add it to the list//
            list.add(f);
        }
        //Here we call the recordHuffmanNodes record the Char and huffman nodes into that 2 LinkList//
        recordHuffmanNodes(Charlist,CodeList,root,"");
        //Then we use Writer and 2 method write HuffmanNodes and frequency, Then translated HuffmanText message into
        // the out put file
        FileWriter fw = new FileWriter(filename);
        writeHuffmanTree(root,"",filename,fw);
        HuffmanCoderReadWrite.Huffman_writeIntoFile(fw,inputFilepath,Charlist,CodeList);
        fw.close();
    }

}



